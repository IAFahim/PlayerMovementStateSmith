// Autogenerated with StateSmith 0.19.0+b5719011215d41a81572ed347c02b22db5d1a48f.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

#nullable enable

// Generated state machine
public partial class PlayerMovementSm
{
    // --- Implementation of methods called by the state machine ---

    private void SetVelocity(float x, float y)
    {
        Console.WriteLine($"Action: Setting velocity to ({x}, {y})");
    }

    private void UpdateAnimation(string animationName)
    {
        Console.WriteLine($"Action: Playing animation '{animationName}'");
    }

    private void SetMovementDirection(object inputDirection)
    {
        Console.WriteLine("Action: Setting movement direction from input");
    }

    private void UpdateVelocity(object inputDirection)
    {
        Console.WriteLine("Action: Updating velocity based on input direction");
    }

    private void StartAttackAnimation()
    {
        Console.WriteLine("Action: Starting attack animation");
    }

    private void PerformAttack()
    {
        Console.WriteLine("Action: Performing attack");
    }

    private void ResetAttack()
    {
        Console.WriteLine("Action: Resetting attack state");
    }

    // Example fields/properties that might be used
    private object inputDirection;
    private bool attackFinished = false;

    public enum EventId
    {
        DO = 0, // The `do` event is special. State event handlers do not consume this event (ancestors all get it too) unless a transition occurs.
        ATTACK_INPUT = 1,
        MOVE_INPUT = 2,
        STOP_INPUT = 3,
    }

    public const int EventIdCount = 4;

    public enum StateId
    {
        ROOT = 0,
        ATTACKING = 1,
        IDLE = 2,
        MOVING = 3,
    }

    public const int StateIdCount = 4;

    // Used internally by state machine. Feel free to inspect, but don't modify.
    public StateId stateId;

    // State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
    public PlayerMovementSm()
    {
    }

    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    public void Start()
    {
        ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.

            // ROOT.<InitialState> behavior
            // uml: TransitionTo(IDLE)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `IDLE`.
                IDLE_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                return;
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }

    // Dispatches an event to the state machine. Not thread safe.
    // Note! This function assumes that the `eventId` parameter is valid.
    public void DispatchEvent(EventId eventId)
    {
        switch (this.stateId)
        {
            // STATE: PlayerMovementSm
            case StateId.ROOT:
                // No events handled by this state (or its ancestors).
                break;

            // STATE: ATTACKING
            case StateId.ATTACKING:
                switch (eventId)
                {
                    case EventId.DO: ATTACKING_do(); break;
                }
                break;

            // STATE: IDLE
            case StateId.IDLE:
                switch (eventId)
                {
                    case EventId.DO: IDLE_do(); break;
                    case EventId.MOVE_INPUT: IDLE_move_input(); break;
                }
                break;

            // STATE: MOVING
            case StateId.MOVING:
                switch (eventId)
                {
                    case EventId.DO: MOVING_do(); break;
                    case EventId.STOP_INPUT: MOVING_stop_input(); break;
                    case EventId.ATTACK_INPUT: MOVING_attack_input(); break;
                }
                break;
        }

    }

    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    private void ExitUpToStateHandler(StateId desiredState)
    {
        while (this.stateId != desiredState)
        {
            switch (this.stateId)
            {
                case StateId.ATTACKING: ATTACKING_exit(); break;

                case StateId.IDLE: IDLE_exit(); break;

                case StateId.MOVING: MOVING_exit(); break;

                default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
            }
        }
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////

    private void ROOT_enter()
    {
        this.stateId = StateId.ROOT;
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ATTACKING
    ////////////////////////////////////////////////////////////////////////////////

    private void ATTACKING_enter()
    {
        this.stateId = StateId.ATTACKING;

        // ATTACKING behavior
        // uml: enter / { StartAttackAnimation(); }
        {
            // Step 1: execute action `StartAttackAnimation();`
            StartAttackAnimation();
        } // end of behavior for ATTACKING
    }

    private void ATTACKING_exit()
    {
        // ATTACKING behavior
        // uml: exit / { ResetAttack(); }
        {
            // Step 1: execute action `ResetAttack();`
            ResetAttack();
        } // end of behavior for ATTACKING

        this.stateId = StateId.ROOT;
    }

    private void ATTACKING_do()
    {
        // ATTACKING behavior
        // uml: do / { PerformAttack(); }
        {
            // Step 1: execute action `PerformAttack();`
            PerformAttack();
        } // end of behavior for ATTACKING

        // ATTACKING behavior
        // uml: do [attackFinished] TransitionTo(IDLE)
        if (attackFinished)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ATTACKING_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `IDLE`.
            IDLE_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for ATTACKING

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state IDLE
    ////////////////////////////////////////////////////////////////////////////////

    private void IDLE_enter()
    {
        this.stateId = StateId.IDLE;

        // IDLE behavior
        // uml: enter / { SetVelocity(0, 0); }
        {
            // Step 1: execute action `SetVelocity(0, 0);`
            SetVelocity(0, 0);
        } // end of behavior for IDLE
    }

    private void IDLE_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void IDLE_do()
    {
        // IDLE behavior
        // uml: do / { UpdateAnimation("Idle"); }
        {
            // Step 1: execute action `UpdateAnimation("Idle");`
            UpdateAnimation("Idle");
        } // end of behavior for IDLE

        // No ancestor handles this event.
    }

    private void IDLE_move_input()
    {
        // IDLE behavior
        // uml: MOVE_INPUT TransitionTo(MOVING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            IDLE_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `MOVING`.
            MOVING_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for IDLE

        // No ancestor handles this event.
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state MOVING
    ////////////////////////////////////////////////////////////////////////////////

    private void MOVING_enter()
    {
        this.stateId = StateId.MOVING;

        // MOVING behavior
        // uml: enter / { SetMovementDirection(inputDirection); }
        {
            // Step 1: execute action `SetMovementDirection(inputDirection);`
            SetMovementDirection(inputDirection);
        } // end of behavior for MOVING
    }

    private void MOVING_exit()
    {
        this.stateId = StateId.ROOT;
    }

    private void MOVING_attack_input()
    {
        // MOVING behavior
        // uml: ATTACK_INPUT TransitionTo(ATTACKING)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            MOVING_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ATTACKING`.
            ATTACKING_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MOVING

        // No ancestor handles this event.
    }

    private void MOVING_do()
    {
        // MOVING behavior
        // uml: do / { UpdateVelocity(inputDirection); }
        {
            // Step 1: execute action `UpdateVelocity(inputDirection);`
            UpdateVelocity(inputDirection);
        } // end of behavior for MOVING

        // MOVING behavior
        // uml: do / { UpdateAnimation("Moving"); }
        {
            // Step 1: execute action `UpdateAnimation("Moving");`
            UpdateAnimation("Moving");
        } // end of behavior for MOVING

        // No ancestor handles this event.
    }

    private void MOVING_stop_input()
    {
        // MOVING behavior
        // uml: STOP_INPUT TransitionTo(IDLE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            MOVING_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `IDLE`.
            IDLE_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for MOVING

        // No ancestor handles this event.
    }

    // Thread safe.
    public static string StateIdToString(StateId id)
    {
        switch (id)
        {
            case StateId.ROOT: return "ROOT";
            case StateId.ATTACKING: return "ATTACKING";
            case StateId.IDLE: return "IDLE";
            case StateId.MOVING: return "MOVING";
            default: return "?";
        }
    }

    // Thread safe.
    public static string EventIdToString(EventId id)
    {
        switch (id)
        {
            case EventId.ATTACK_INPUT: return "ATTACK_INPUT";
            case EventId.DO: return "DO";
            case EventId.MOVE_INPUT: return "MOVE_INPUT";
            case EventId.STOP_INPUT: return "STOP_INPUT";
            default: return "?";
        }
    }
}
